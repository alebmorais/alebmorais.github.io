#!/usr/bin/env python3
"""
Servidor de Automação Médica - Dr. Alessandra Morais
Versão robusta com tratamento de erros e formatação correta
"""
import sqlite3
import json
import os
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler
import urllib.parse
import traceback

class MedicalAutomationServer:
    def __init__(self, db_path='/home/pi/automation.db'):
        self.db_path = db_path
        self.verify_database()

    def verify_database(self):
        """Verificar se banco de dados existe e tem dados"""
        if not os.path.exists(self.db_path):
            print(f"ERRO: Banco de dados não encontrado em {self.db_path}")
            sys.exit(1)
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.execute("SELECT COUNT(*) FROM frases")
            count = cursor.fetchone()[0]
            conn.close()
            if count == 0:
                print("AVISO: Banco de dados vazio")
            else:
                print(f"✓ Banco de dados OK: {count} frases encontradas")
        except Exception as e:
            print(f"ERRO no banco de dados: {e}")
            sys.exit(1)

    def get_categorias_principais(self):
        """Buscar categorias principais"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.execute("SELECT DISTINCT categoria_principal FROM frases ORDER BY categoria_principal")
            categorias = [row[0] for row in cursor]
            conn.close()
            return categorias
        except Exception as e:
            print(f"Erro ao buscar categorias: {e}")
            return []

    def get_subcategorias(self, categoria_principal):
        """Buscar subcategorias de uma categoria"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.execute(
                "SELECT DISTINCT subcategoria FROM frases WHERE categoria_principal = ? ORDER BY subcategoria",
                (categoria_principal,)
            )
            subcategorias = [row[0] for row in cursor]
            conn.close()
            return subcategorias
        except Exception as e:
            print(f"Erro ao buscar subcategorias: {e}")
            return []

    def get_frases(self, categoria_principal=None, subcategoria=None):
        """Buscar frases com filtros opcionais"""
        try:
            conn = sqlite3.connect(self.db_path)
            if categoria_principal and subcategoria:
                cursor = conn.execute(
                    "SELECT * FROM frases WHERE categoria_principal = ? AND subcategoria = ? ORDER BY ordem",
                    (categoria_principal, subcategoria)
                )
            elif categoria_principal:
                cursor = conn.execute(
                    "SELECT * FROM frases WHERE categoria_principal = ? ORDER BY subcategoria, ordem",
                    (categoria_principal,)
                )
            else:
                cursor = conn.execute("SELECT * FROM frases ORDER BY categoria_principal, subcategoria, ordem")
            frases = []
            for row in cursor:
                frases.append({
                                        'id': row[0],
                    'nome': row[1],
                    'conteudo': row[2],
                    'categoria_principal': row[3],
                    'subcategoria': row[4],
                    'ordem': row[5]
                })
            conn.close()
            return frases
        except Exception as e:
            print(f"Erro ao buscar frases: {e}")
            return []

class WebRequestHandler(BaseHTTPRequestHandler):
    def __init__(self, *args, automation_server=None, **kwargs):
        self.automation_server = automation_server
        super().__init__(*args, **kwargs)

    def log_message(self, format, *args):
        """Suprimir logs desnecessarios"""
        pass

    def do_GET(self):
        """Processar requisicoes GET"""
        try:
            parsed_url = urllib.parse.urlparse(self.path)
            path.split('/') if part]

            if path == '/':
                self.send_medical_interface()
                return

            stripped_path = path.strip('/')
            path_parts = stripped_path.split('/') if stripped_path else []

            if path == '/api/categorias':
                categorias = self.automation_server.get_categorias_principais()
                self.send_json_response(categorias)
                return

            if len(path_parts) >= 2 and path_parts[0] == 'api' and path_parts[1] == 'subcategorias':
                if len(path_parts) == 2:
                    self.send_error(400, "Categoria não especificada")
                    return

                categoria = urllib.parse.unquote('/'.join(path_parts[2:]))
                if not categoria:
                    self.send_error(400, "Categoria não especificada")
                    return

                subcategorias = self.automation_server.get_subcategorias(categoria)
                self.send_json_response(subcategorias)
                return

            if len(path_parts) >= 2 and path_parts[0] == 'api' and path_parts[1] == 'frases':
                if len(path_parts) == 2:
                    query_params = urllib.parse.parse_qs(parsed_url.query)
                    categoria = query_params.get('categoria', [None])[0] or None
                    subcategoria = query_params.get('subcategoria', [None])[0] or None
                    frases = self.automation_server.get_frases(categoria, subcategoria)
                    self.send_json_response(frases)
                    return

                categoria = urllib.parse.unquote(path_parts[2]) if len(path_parts) >= 3 else None
                subcategoria = urllib.parse.unquote(path_parts[3]) if len(path_parts) >= 4 else None

                if categoria in (None, ''):
                    self.send_error(400, "Categoria não especificada")
                    return

                if len(path_parts) >= 4 and subcategoria == '':
                    self.send_error(400, "Subcategoria não especificada")
                    return

                frases = self.automation_server.get_frases(categoria, subcategoria)
                self.send_json_response(frases)
                return

            self.send_error(404, "Página não encontrada")
        except Exception as e:
            print(f"Erro na requisição {self.path}: {e}")
            traceback.print_exc()
            self.send_error(500, "Erro interno do servidor")

    def send_json_response(self, data):
        """Enviar resposta JSON"""
        try:
            self.send_response(200)
            self.send_header('Content-Type', 'application/json; charset=utf-8')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Cache-Control', 'no-cache')
            self.end_headers()
            json_data = json.dumps(data, ensure_ascii=False, indent=2)
            self.wfile.write(json_data.encode('utf-8'))
        except Exception as e:
            print(f"Erro ao enviar JSON: {e}")
            self.send_error(500, "Erro ao processar dados")

    def send_medical_interface(self):
        """Enviar interface HTML"""
        html_content = self.get_html_template()
        try:
            self.send_response(200)
            self.send_header('Content-Type', 'text/html; charset=utf-8')
            self.send_header('Cache-Control', 'no-cache')
            self.end_headers()
            self.wfile.write(html_content.encode('utf-8'))
        except Exception as e:
            print(f"Erro ao enviar HTML: {e}")
            self.send_error(500, "Erro ao carregar interface")

    def get_html_template(self):
        """Template HTML completo e funcional"""
        return '''<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Servidor de Automação Médica</title>
</head>
<body>
    <h1>Servidor de Automação Médica</h1>
    <p>Interface em desenvolvimento.</p>
</body>
</html>'''


def run_server():
    db_path = os.environ.get('DB_PATH', '/home/pi/automation.db')
    automation_server = MedicalAutomationServer(db_path=db_path)
    def handler(*args, **kwargs):
        WebRequestHandler(*args, automation_server=automation_server, **kwargs)
    server_address = ('', 8080)
    httpd = HTTPServer(server_address, handler)
    print(f"Servidor rodando em http://localhost:8080 ...")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nServidor encerrado pelo usuário.")
    finally:
        httpd.server_close()

if __name__ == "__main__":
    run_server()
